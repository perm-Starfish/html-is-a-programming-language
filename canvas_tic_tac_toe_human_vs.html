<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Canvas Tic‑Tac‑Toe — Human vs Computer (Perfect AI)</title>
<style>
  :root { --size: 480px; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
  body{display:grid;place-items:center;min-height:100vh;background:#0b1020;color:#e6edf3;margin:0;}
  .card{background:#121a2a;border:1px solid #22314f;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:18px;max-width:860px;width:min(92vw,860px);}
  h1{font-size:1.15rem;margin:0 0 10px;letter-spacing:.3px;color:#c9d1d9}
  .row{display:flex;gap:18px;flex-wrap:wrap;align-items:center}
  canvas{background:#0f1626;border-radius:12px;border:1px solid #33476e;width:var(--size);height:var(--size);touch-action:manipulation;cursor:pointer}
  .panel{display:flex;flex-direction:column;gap:10px;min-width:260px}
  .panel .status{background:#0f1626;border:1px solid #33476e;border-radius:10px;padding:12px;min-height:48px}
  button, select{appearance:none;background:#1a2440;border:1px solid #33476e;color:#e6edf3;padding:10px 12px;border-radius:10px;font-weight:600;cursor:pointer}
  button:hover{background:#223159}
  .note{font-size:.9rem;opacity:.85}
  .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;background:#0f1626;border:1px solid #33476e;border-radius:6px;padding:2px 6px}
</style>
</head>
<body>
  <div class="card">
    <h1>Canvas Tic‑Tac‑Toe — Human vs Computer (Perfect AI)</h1>
    <div class="row">
      <canvas id="board" width="600" height="600" aria-label="Tic-Tac-Toe board" role="img"></canvas>
      <div class="panel">
        <div class="status" id="status">Choose who starts and click a square.</div>
        <div class="row" style="gap:10px">
          <label>Play as
            <select id="side">
              <option value="X">X (first)</option>
              <option value="O">O (second)</option>
            </select>
          </label>
          <button id="new">New Game</button>
        </div>
        <div class="note">
          • Click a square to place your mark. The AI uses <span class="kbd">minimax</span> with pruning, so it will never lose.<br>
          • Press <span class="kbd">N</span> for a new game.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const sideSel = document.getElementById('side');
  const newBtn = document.getElementById('new');

  // HiDPI / devicePixelRatio scaling for crisp lines
  function fitToDevicePixelRatio() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssSize = parseInt(getComputedStyle(canvas).width);
    canvas.width = cssSize * dpr;
    canvas.height = cssSize * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    size = cssSize; // logical drawing size in CSS pixels
    cell = size / 3;
  }

  let size = 480; // logical px (updated by fitToDevicePixelRatio)
  let cell = size / 3;

  window.addEventListener('resize', () => { fitToDevicePixelRatio(); draw(); });
  fitToDevicePixelRatio();

  // Game state
  let board = Array(9).fill(null); // indexes 0..8
  let human = 'X';
  let ai = 'O';
  let over = false;
  let lastAIMove = -1;

  function reset() {
    board.fill(null);
    over = false;
    lastAIMove = -1;
    human = sideSel.value;
    ai = human === 'X' ? 'O' : 'X';
    setStatus(`${human} to move.`);
    draw();
    if (human === 'O') {
      // AI starts
      aiMove();
    }
  }

  newBtn.addEventListener('click', reset);
  sideSel.addEventListener('change', reset);
  window.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'n') reset(); });

  canvas.addEventListener('click', (e) => {
    if (over) return;
    const { left, top } = canvas.getBoundingClientRect();
    const x = e.clientX - left;
    const y = e.clientY - top;
    const c = Math.floor(x / (size/3));
    const r = Math.floor(y / (size/3));
    const idx = r * 3 + c;
    if (idx < 0 || idx > 8) return;
    if (board[idx] !== null) return;
    if (currentPlayer() !== human) return;

    board[idx] = human;
    lastAIMove = -1;
    draw();
    checkEndOrAIMove();
  });

  function currentPlayer() {
    const countX = board.filter(v => v === 'X').length;
    const countO = board.filter(v => v === 'O').length;
    return countX === countO ? 'X' : 'O';
  }

  function setStatus(msg) { statusEl.textContent = msg; }

  function drawGrid() {
    ctx.clearRect(0,0,size,size);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // background
    ctx.fillStyle = '#0f1626';
    ctx.fillRect(0, 0, size, size);

    // grid lines
    ctx.strokeStyle = '#3a547f';
    ctx.lineWidth = 6;
    for (let i = 1; i <= 2; i++) {
      // vertical
      ctx.beginPath();
      ctx.moveTo(i*cell, 18);
      ctx.lineTo(i*cell, size-18);
      ctx.stroke();
      // horizontal
      ctx.beginPath();
      ctx.moveTo(18, i*cell);
      ctx.lineTo(size-18, i*cell);
      ctx.stroke();
    }
  }

  function drawMarks() {
    ctx.lineWidth = 10;
    for (let i = 0; i < 9; i++) {
      const mark = board[i];
      if (!mark) continue;
      const r = Math.floor(i / 3), c = i % 3;
      const cx = c * cell + cell/2;
      const cy = r * cell + cell/2;
      if (mark === 'X') drawX(cx, cy);
      else drawO(cx, cy);
    }

    // highlight last AI move
    if (lastAIMove >= 0) {
      const r = Math.floor(lastAIMove / 3), c = lastAIMove % 3;
      ctx.strokeStyle = 'rgba(255,255,255,0.55)';
      ctx.lineWidth = 4;
      const pad = 8;
      ctx.strokeRect(c*cell+pad, r*cell+pad, cell-2*pad, cell-2*pad);
    }
  }

  function drawX(cx, cy) {
    const s = cell * 0.28;
    ctx.strokeStyle = '#64b5f6';
    ctx.beginPath();
    ctx.moveTo(cx - s, cy - s);
    ctx.lineTo(cx + s, cy + s);
    ctx.moveTo(cx + s, cy - s);
    ctx.lineTo(cx - s, cy + s);
    ctx.stroke();
  }

  function drawO(cx, cy) {
    const r = cell * 0.31;
    ctx.strokeStyle = '#ffcc80';
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();
  }

  function drawWinLine(win) {
    if (!win) return;
    const [a,b,c] = win.line;
    const pts = [a,b,c].map(i => ({ r: Math.floor(i/3), c: i%3 }));
    const start = { x: pts[0].c*cell + cell/2, y: pts[0].r*cell + cell/2 };
    const end   = { x: pts[2].c*cell + cell/2, y: pts[2].r*cell + cell/2 };
    ctx.strokeStyle = '#7ee787';
    ctx.lineWidth = 12;
    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(end.x, end.y);
    ctx.stroke();
  }

  function draw() {
    drawGrid();
    drawMarks();
    const win = getWinner(board);
    drawWinLine(win);
  }

  const LINES = [
    [0,1,2],[3,4,5],[6,7,8], // rows
    [0,3,6],[1,4,7],[2,5,8], // cols
    [0,4,8],[2,4,6]          // diags
  ];

  function getWinner(b) {
    for (const line of LINES) {
      const [a,b2,c] = line;
      if (b[a] && b[a] === b[b2] && b[a] === b[c]) return { player: b[a], line };
    }
    if (b.every(v => v)) return { player: null, line: null, draw: true };
    return null;
  }

  function checkEndOrAIMove() {
    const w = getWinner(board);
    if (w) {
      over = true;
      draw();
      if (w.draw) setStatus('Draw. Press New Game to play again.');
      else setStatus(`${w.player} wins! Press New Game to play again.`);
      return;
    }
    if (currentPlayer() === ai) {
      aiMove();
    } else {
      setStatus(`${human} to move.`);
    }
  }

  // Perfect AI via minimax with alpha-beta pruning.
  function aiMove() {
    // if first move and center is free, take center (speed optimization)
    if (board.filter(Boolean).length === 0) {
      placeAt(4);
      return;
    }

    const best = findBestMove(board, ai);
    placeAt(best.index);

    function placeAt(i){
      board[i] = ai;
      lastAIMove = i;
      draw();
      const w = getWinner(board);
      if (w) {
        over = true; draw();
        if (w.draw) setStatus('Draw. Press New Game to play again.');
        else setStatus(`${w.player} wins! Press New Game to play again.`);
      } else {
        setStatus(`${human} to move.`);
      }
    }
  }

  function findBestMove(b, player) {
    let bestScore = -Infinity; let bestIdx = -1;
    for (let i = 0; i < 9; i++) {
      if (b[i] === null) {
        b[i] = player;
        const score = minimax(b, 0, false, player, other(player), -Infinity, Infinity);
        b[i] = null;
        if (score > bestScore) { bestScore = score; bestIdx = i; }
      }
    }
    return { index: bestIdx, score: bestScore };
  }

  function minimax(b, depth, isMax, me, opp, alpha, beta) {
    const w = getWinner(b);
    if (w) {
      if (w.draw) return 0;
      return w.player === me ? (10 - depth) : (depth - 10);
    }

    if (isMax) {
      let best = -Infinity;
      // Small heuristic: prefer center, corners, sides
      for (const i of orderMoves(b)) {
        b[i] = me;
        best = Math.max(best, minimax(b, depth+1, false, me, opp, alpha, beta));
        b[i] = null;
        alpha = Math.max(alpha, best);
        if (beta <= alpha) break; // prune
      }
      return best;
    } else {
      let best = Infinity;
      for (const i of orderMoves(b)) {
        b[i] = opp;
        best = Math.min(best, minimax(b, depth+1, true, me, opp, alpha, beta));
        b[i] = null;
        beta = Math.min(beta, best);
        if (beta <= alpha) break;
      }
      return best;
    }
  }

  function orderMoves(b) {
    const priorities = [4,0,2,6,8,1,3,5,7]; // center, corners, sides
    return priorities.filter(i => b[i] === null);
  }

  function other(p){ return p === 'X' ? 'O' : 'X'; }

  // Initial draw & start
  draw();
  reset();
})();
</script>
</body>
</html>
