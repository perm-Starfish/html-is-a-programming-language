<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Multi-Key Compass Spaceship</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #0f0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
    }

    #hud {
      margin-bottom: 8px;
      padding: 8px 12px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #0f0;
      font-size: 14px;
      line-height: 1.4;
      min-width: 320px;
    }

    #hud span.label {
      color: #aaa;
      margin-right: 4px;
    }

    canvas {
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.35);
      background: #000;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div><span class="label">Compass:</span><span id="directionText">None</span></div>
    <div><span class="label">Pressed (NumPad):</span><span id="numpadText">[]</span></div>
    <div><span class="label">Pressed (Arrows):</span><span id="arrowText">[]</span></div>
    <div><span class="label">Hint:</span> Use NumPad 1–4,6–9 or Arrow keys. Shift = torpedo, Space = laser.</div>
  </div>

  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const dirTextEl = document.getElementById('directionText');
    const numpadTextEl = document.getElementById('numpadText');
    const arrowTextEl = document.getElementById('arrowText');

    // ====== INPUT STATE ======
    const numpadKeysDown = new Set();   // '1','2','3','4','6','7','8','9'
    const arrowKeysDown = new Set();    // 'Up','Down','Left','Right'
    let shiftDown = false;
    let laserActive = false;

    // Numeric keypad: math coordinates (x right, y up)
    const numpadVectors = {
      '8': {x: 0,  y:  1},  // N
      '9': {x: 1,  y:  1},  // NE
      '6': {x: 1,  y:  0},  // E
      '3': {x: 1,  y: -1},  // SE
      '2': {x: 0,  y: -1},  // S
      '1': {x: -1, y: -1},  // SW
      '4': {x: -1, y:  0},  // W
      '7': {x: -1, y:  1}   // NW
    };

    const arrowVectors = {
      'Up':    {x: 0,  y:  1},  // N
      'Right': {x: 1,  y:  0},  // E
      'Down':  {x: 0,  y: -1},  // S
      'Left':  {x: -1, y:  0}   // W
    };

    // ====== COMPASS DEFINITIONS ======
    // Angles are in "math" degrees: 0° = East, 90° = North, CCW positive
    const compass16 = [
      { name: 'N',   deg: 90 },
      { name: 'NNE', deg: 67.5 },
      { name: 'NE',  deg: 45 },
      { name: 'ENE', deg: 22.5 },
      { name: 'E',   deg: 0 },
      { name: 'ESE', deg: 337.5 },
      { name: 'SE',  deg: 315 },
      { name: 'SSE', deg: 292.5 },
      { name: 'S',   deg: 270 },
      { name: 'SSW', deg: 247.5 },
      { name: 'SW',  deg: 225 },
      { name: 'WSW', deg: 202.5 },
      { name: 'W',   deg: 180 },
      { name: 'WNW', deg: 157.5 },
      { name: 'NW',  deg: 135 },
      { name: 'NNW', deg: 112.5 }
    ];

    const compass8Names = new Set(['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']);
    const compass8 = compass16.filter(d => compass8Names.has(d.name));

    function normalizeDeg(deg) {
      deg = deg % 360;
      if (deg < 0) deg += 360;
      return deg;
    }

    function nearestDirection(deg, candidates) {
      let best = candidates[0];
      let bestDiff = 999;
      for (const c of candidates) {
        let diff = Math.abs(normalizeDeg(deg) - normalizeDeg(c.deg));
        if (diff > 180) diff = 360 - diff;
        if (diff < bestDiff) {
          bestDiff = diff;
          best = c;
        }
      }
      return best;
    }

    // Convert math-deg (0°=E, 90°=N) into "compass radians" for drawing/movement
    // where 0 rad = North, positive is clockwise.
    function compassDegToRad(degMath) {
      return (90 - normalizeDeg(degMath)) * Math.PI / 180;
    }

    function getAngleFromVectors(vectors, keySet) {
      if (keySet.size === 0) return null;
      let x = 0, y = 0;
      for (const k of keySet) {
        const v = vectors[k];
        if (v) {
          x += v.x;
          y += v.y;
        }
      }
      if (x === 0 && y === 0) return null;
      const rad = Math.atan2(y, x); // math coords
      let deg = rad * 180 / Math.PI;
      deg = normalizeDeg(deg);
      return deg;
    }

    function computeCompassDirection() {
      // Numeric keypad has priority
      if (numpadKeysDown.size > 0) {
        const deg = getAngleFromVectors(numpadVectors, numpadKeysDown);
        if (deg == null) return null;
        const dir = nearestDirection(deg, compass16);
        return {
          label: dir.name,
          angleRad: compassDegToRad(dir.deg)
        };
      }

      // If no numeric keypad, use arrows (8-point)
      if (arrowKeysDown.size > 0) {
        const deg = getAngleFromVectors(arrowVectors, arrowKeysDown);
        if (deg == null) return null;
        const dir = nearestDirection(deg, compass8);
        return {
          label: dir.name,
          angleRad: compassDegToRad(dir.deg)
        };
      }

      return null;
    }

    // ====== SPACESHIP STATE ======
    const ship = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      angle: 0,           // current compass radians (0 = North)
      targetAngle: 0,     // compass radians
      radius: 25,
      moveSpeed: 100      // px per second
    };

    const rotationSpeed = 2 * Math.PI; // 1 full rotation per second

    // ====== PROJECTILES ======
    const torpedoes = [];
    const torpedoSpeed = 300; // px/s

    // ====== STARFIELD ======
    const stars = [];
    const STAR_COUNT = 150;

    function initStars() {
      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: Math.random() * 1.5 + 0.5,
          a: Math.random() * 2 * Math.PI,
          twinkleSpeed: Math.random() * 2 + 1
        });
      }
    }

    initStars();

    // ====== INPUT HANDLERS ======
    window.addEventListener('keydown', (e) => {
      const code = e.code;

      // Prevent scrolling on arrow keys/space etc.
      if (
        code.startsWith('Arrow') ||
        code.startsWith('Numpad') ||
        code === 'Space' ||
        code.startsWith('Shift')
      ) {
        e.preventDefault();
      }

      if (code.startsWith('Numpad')) {
        const digit = code.slice(-1);
        if ('12346789'.includes(digit)) {
          numpadKeysDown.add(digit);
        }
      }

      if (code === 'ArrowUp') arrowKeysDown.add('Up');
      if (code === 'ArrowDown') arrowKeysDown.add('Down');
      if (code === 'ArrowLeft') arrowKeysDown.add('Left');
      if (code === 'ArrowRight') arrowKeysDown.add('Right');

      if (code === 'Space') {
        laserActive = true;
      }

      if (code === 'ShiftLeft' || code === 'ShiftRight') {
        if (!shiftDown) {
          fireTorpedo();
        }
        shiftDown = true;
      }

      updateHUD();
    });

    window.addEventListener('keyup', (e) => {
      const code = e.code;

      if (code.startsWith('Numpad')) {
        const digit = code.slice(-1);
        if ('12346789'.includes(digit)) {
          numpadKeysDown.delete(digit);
        }
      }

      if (code === 'ArrowUp') arrowKeysDown.delete('Up');
      if (code === 'ArrowDown') arrowKeysDown.delete('Down');
      if (code === 'ArrowLeft') arrowKeysDown.delete('Left');
      if (code === 'ArrowRight') arrowKeysDown.delete('Right');

      if (code === 'Space') {
        laserActive = false;
      }

      if (code === 'ShiftLeft' || code === 'ShiftRight') {
        shiftDown = false;
      }

      updateHUD();
    });

    function updateHUD() {
      numpadTextEl.textContent = '[' + Array.from(numpadKeysDown).join(', ') + ']';
      arrowTextEl.textContent = '[' + Array.from(arrowKeysDown).join(', ') + ']';
    }

    function fireTorpedo() {
      const nose = getShipNose();
      const vx = Math.sin(ship.angle) * torpedoSpeed;
      const vy = -Math.cos(ship.angle) * torpedoSpeed;
      torpedoes.push({
        x: nose.x,
        y: nose.y,
        vx,
        vy
      });
    }

    function getShipNose() {
      // Nose of ship in front direction
      return {
        x: ship.x + Math.sin(ship.angle) * ship.radius,
        y: ship.y - Math.cos(ship.angle) * ship.radius
      };
    }

    // ====== UPDATE LOOP ======
    let lastTime = performance.now();

    function gameLoop(timestamp) {
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      update(dt);
      draw();

      requestAnimationFrame(gameLoop);
    }

    function update(dt) {
      // 1. Direction from keyboard
      const dir = computeCompassDirection();
      if (dir && typeof dir.angleRad === 'number') {
        ship.targetAngle = dir.angleRad;
        dirTextEl.textContent = dir.label;
      } else {
        dirTextEl.textContent = 'None';
        // targetAngle stays as is (ship keeps its orientation)
      }

      // 2. Rotate ship towards targetAngle at fixed speed, shortest way
      const diff = shortestAngularDifference(ship.angle, ship.targetAngle);
      const maxStep = rotationSpeed * dt;
      if (Math.abs(diff) <= maxStep) {
        ship.angle = ship.targetAngle;
      } else {
        ship.angle += Math.sign(diff) * maxStep;
      }

      // 3. Move ship at constant speed in its current orientation
      const dx = Math.sin(ship.angle) * ship.moveSpeed * dt;
      const dy = -Math.cos(ship.angle) * ship.moveSpeed * dt;

      let nextX = ship.x + dx;
      let nextY = ship.y + dy;
      const r = ship.radius;

      // Stop at window edges (no wrapping)
      if (nextX < r || nextX > canvas.width - r) {
        nextX = ship.x;
      }
      if (nextY < r || nextY > canvas.height - r) {
        nextY = ship.y;
      }

      ship.x = nextX;
      ship.y = nextY;

      // 4. Update torpedoes
      for (let i = torpedoes.length - 1; i >= 0; i--) {
        const t = torpedoes[i];
        t.x += t.vx * dt;
        t.y += t.vy * dt;

        if (
          t.x < 0 || t.x > canvas.width ||
          t.y < 0 || t.y > canvas.height
        ) {
          torpedoes.splice(i, 1);
        }
      }

      // 5. Twinkle stars
      for (const s of stars) {
        s.a += s.twinkleSpeed * dt;
      }
    }

    function shortestAngularDifference(a, b) {
      let diff = (b - a + Math.PI) % (2 * Math.PI) - Math.PI;
      if (diff < -Math.PI) diff += 2 * Math.PI;
      return diff;
    }

    // ====== DRAWING ======
    function drawStarfield() {
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (const s of stars) {
        const brightness = 0.6 + 0.4 * Math.sin(s.a);
        ctx.globalAlpha = brightness;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
      }
      ctx.globalAlpha = 1.0;
    }

    function drawShip() {
      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.angle);

      // 90x90-ish footprint, centered (approx)
      // body
      ctx.beginPath();
      ctx.moveTo(0, -28);       // nose
      ctx.lineTo(16, 16);       // right wing tip
      ctx.lineTo(8, 10);        // right inner
      ctx.lineTo(0, 20);        // tail
      ctx.lineTo(-8, 10);       // left inner
      ctx.lineTo(-16, 16);      // left wing tip
      ctx.closePath();

      // glow & border
      ctx.shadowBlur = 10;
      ctx.shadowColor = '#0ff';
      ctx.fillStyle = '#0ff';
      ctx.fill();
      ctx.shadowBlur = 0;

      ctx.lineWidth = 2;
      ctx.strokeStyle = '#033';
      ctx.stroke();

      // cockpit
      ctx.beginPath();
      ctx.arc(0, -10, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#00f';
      ctx.fill();

      // engine glow
      ctx.beginPath();
      ctx.moveTo(0, 20);
      ctx.lineTo(6, 26);
      ctx.lineTo(-6, 26);
      ctx.closePath();
      ctx.fillStyle = '#f80';
      ctx.fill();

      ctx.restore();
    }

    function drawTorpedoes() {
      ctx.lineWidth = 2;
      for (const t of torpedoes) {
        ctx.beginPath();
        ctx.arc(t.x, t.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#ff0';
        ctx.fill();
      }
    }

    function drawLaser() {
      if (!laserActive) return;
      const nose = getShipNose();
      const length = 1000; // long enough to go off-screen
      const endX = nose.x + Math.sin(ship.angle) * length;
      const endY = nose.y - Math.cos(ship.angle) * length;

      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.beginPath();
      ctx.moveTo(nose.x, nose.y);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = '#0f0';
      ctx.lineWidth = 3;
      ctx.stroke();

      // inner core
      ctx.globalAlpha = 1.0;
      ctx.beginPath();
      ctx.moveTo(nose.x, nose.y);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.restore();
    }

    function draw() {
      drawStarfield();
      drawTorpedoes();
      drawLaser();
      drawShip();
    }

    // Start the loop
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
